\BOOKMARK [1][-]{section.1}{Introduction}{}% 1
\BOOKMARK [1][-]{section.2}{Gradual typing}{}% 2
\BOOKMARK [2][-]{subsection.2.1}{Gradual typing by examples}{section.2}% 3
\BOOKMARK [2][-]{subsection.2.2}{Theory}{section.2}% 4
\BOOKMARK [3][-]{subsubsection.2.2.1}{Gradual Typing for functional languages}{subsection.2.2}% 5
\BOOKMARK [3][-]{subsubsection.2.2.2}{Gradual typing for objects}{subsection.2.2}% 6
\BOOKMARK [3][-]{subsubsection.2.2.3}{Gradual typing for generics}{subsection.2.2}% 7
\BOOKMARK [3][-]{subsubsection.2.2.4}{Refined criteria for gradual typing}{subsection.2.2}% 8
\BOOKMARK [2][-]{subsection.2.3}{Gradual typing vs type inference}{section.2}% 9
\BOOKMARK [2][-]{subsection.2.4}{Applications in concrete languages}{section.2}% 10
\BOOKMARK [1][-]{section.3}{Gradual Verification}{}% 11
\BOOKMARK [2][-]{subsection.3.1}{Gradual effects}{section.3}% 12
\BOOKMARK [2][-]{subsection.3.2}{Gradual ownership types}{section.3}% 13
\BOOKMARK [2][-]{subsection.3.3}{Gradual security typing}{section.3}% 14
\BOOKMARK [2][-]{subsection.3.4}{Gradual annotated type systems}{section.3}% 15
\BOOKMARK [2][-]{subsection.3.5}{Gradual typestate}{section.3}% 16
\BOOKMARK [1][-]{section.4}{Challenges and Conclusion}{}% 17
\BOOKMARK [2][-]{subsection.4.1}{Resolving performance issues}{section.4}% 18
\BOOKMARK [2][-]{subsection.4.2}{Application to other typing disciplines}{section.4}% 19
\BOOKMARK [2][-]{subsection.4.3}{Unifying theory and principles \(AGT\)}{section.4}% 20
