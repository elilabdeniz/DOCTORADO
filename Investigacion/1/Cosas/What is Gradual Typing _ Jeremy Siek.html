<!DOCTYPE html>
<!-- saved from url=(0061)http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/ -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>What is Gradual Typing | Jeremy Siek</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="stylesheet" type="text/css" media="all" href="./What is Gradual Typing _ Jeremy Siek_files/style.css">
<link rel="pingback" href="http://wphomes.soic.indiana.edu/jsiek/xmlrpc.php">

<!-- All in One SEO Pack 2.2.7.4 by Michael Torbert of Semper Fi Web Design[68,111] -->
<meta name="description" itemprop="description" content="(For a Japanese translation, go here) Gradual typing is a type system I developed with Walid Taha in 2006 that allows parts of a program to be dynamically">

<link rel="canonical" href="./What is Gradual Typing _ Jeremy Siek_files/What is Gradual Typing _ Jeremy Siek.html">
<!-- /all in one seo pack -->
<link rel="alternate" type="application/rss+xml" title="Jeremy Siek » Feed" href="http://wphomes.soic.indiana.edu/jsiek/feed/">
<link rel="alternate" type="application/rss+xml" title="Jeremy Siek » Comments Feed" href="http://wphomes.soic.indiana.edu/jsiek/comments/feed/">
<link rel="alternate" type="application/rss+xml" title="Jeremy Siek » What is Gradual Typing Comments Feed" href="http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/feed/">
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/wphomes.soic.indiana.edu\/jsiek\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4"}};
			!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56806,55356,56826),0,0),c.toDataURL().length>3e3):("simple"===a?d.fillText(String.fromCharCode(55357,56835),0,0):d.fillText(String.fromCharCode(55356,57135),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script><script src="./What is Gradual Typing _ Jeremy Siek_files/wp-emoji-release.min.js" type="text/javascript"></script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel="stylesheet" id="contact-form-7-css" href="./What is Gradual Typing _ Jeremy Siek_files/styles.css" type="text/css" media="all">
<link rel="stylesheet" id="font-awesome-four-css" href="./What is Gradual Typing _ Jeremy Siek_files/font-awesome.min.css" type="text/css" media="all">
<script type="text/javascript" src="./What is Gradual Typing _ Jeremy Siek_files/jquery.js"></script>
<script type="text/javascript" src="./What is Gradual Typing _ Jeremy Siek_files/jquery-migrate.min.js"></script>
<link rel="https://api.w.org/" href="http://wphomes.soic.indiana.edu/jsiek/wp-json/">
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://wphomes.soic.indiana.edu/jsiek/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://wphomes.soic.indiana.edu/jsiek/wp-includes/wlwmanifest.xml"> 
<link rel="prev" title="Keynote at TFP 2013" href="http://wphomes.soic.indiana.edu/jsiek/keynote-at-tfp-2013/">
<meta name="generator" content="WordPress 4.4">
<link rel="shortlink" href="http://wphomes.soic.indiana.edu/jsiek/?p=101">
<link rel="alternate" type="application/json+oembed" href="http://wphomes.soic.indiana.edu/jsiek/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwphomes.soic.indiana.edu%2Fjsiek%2Fwhat-is-gradual-typing%2F">
<link rel="alternate" type="text/xml+oembed" href="http://wphomes.soic.indiana.edu/jsiek/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwphomes.soic.indiana.edu%2Fjsiek%2Fwhat-is-gradual-typing%2F&amp;format=xml">
<meta name="generator" content="Powered by Visual Composer - drag and drop page builder for WordPress.">
<!--[if IE 8]><link rel="stylesheet" type="text/css" href="http://wphomes.soic.indiana.edu/jsiek/wp-content/plugins/js_composer/assets/css/vc-ie8.css" media="screen"><![endif]--></head>

<body class="single single-post postid-101 single-format-standard wpb-js-composer js-comp-ver-4.4.2 vc_responsive">
<div id="wrapper" class="hfeed">
	<div id="header">
		<div id="masthead">
			<div id="branding" role="banner">
								<div id="site-title">
					<span>
						<a href="http://wphomes.soic.indiana.edu/jsiek/" title="Jeremy Siek" rel="home">Jeremy Siek</a>
					</span>
				</div>
				<div id="site-description">Indiana University Bloomington</div>

										<img src="./What is Gradual Typing _ Jeremy Siek_files/cropped-fall-colors.jpg" width="940" height="198" alt="">
								</div><!-- #branding -->

			<div id="access" role="navigation">
			  				<div class="skip-link screen-reader-text"><a href="http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/#content" title="Skip to content">Skip to content</a></div>
								<div class="menu"><ul><li><a href="http://wphomes.soic.indiana.edu/jsiek/">Home</a></li><li class="page_item page-item-10 current_page_parent"><a href="http://wphomes.soic.indiana.edu/jsiek/posts/">News</a></li></ul></div>
			</div><!-- #access -->
		</div><!-- #masthead -->
	</div><!-- #header -->

	<div id="main">

		<div id="container">
			<div id="content" role="main">

			

				<div id="nav-above" class="navigation">
					<div class="nav-previous"><a href="http://wphomes.soic.indiana.edu/jsiek/keynote-at-tfp-2013/" rel="prev"><span class="meta-nav">←</span> Keynote at TFP 2013</a></div>
					<div class="nav-next"></div>
				</div><!-- #nav-above -->

				<div id="post-101" class="post-101 post type-post status-publish format-standard hentry category-blog">
					<h1 class="entry-title">What is Gradual Typing</h1>

					<div class="entry-meta">
						<span class="meta-prep meta-prep-author">Posted on</span> <a href="./What is Gradual Typing _ Jeremy Siek_files/What is Gradual Typing _ Jeremy Siek.html" title="10:28 am" rel="bookmark"><span class="entry-date">March 24, 2014</span></a> <span class="meta-sep">by</span> <span class="author vcard"><a class="url fn n" href="http://wphomes.soic.indiana.edu/jsiek/author/jsiek/" title="View all posts by jsiek">jsiek</a></span>					</div><!-- .entry-meta -->

					<div class="entry-content">
						<p>(For a Japanese translation, go <a href="http://qiita.com/t2y/items/0a604384e18db0944398">here</a>)</p>
<p>Gradual typing is a type system I developed with Walid Taha in 2006 that<br>
allows parts of a program to be <em>dynamically typed</em> and other<br>
parts to be <em>statically typed</em>. The programmer controls which<br>
parts are which by either leaving out type annotations or by adding<br>
them in. This article gives a gentle introduction to gradual typing.</p>
<p>The following were our motivations for developing gradual typing:</p>
<ul>
<li>Large software systems are often developed in multiple languages<br>
partly because dynamically typed languages are better for some tasks<br>
and statically typed languages are better for others. With a gradual type<br>
system, the programmer can choose between static and dynamic typing<br>
without having to switch to a different language and without having<br>
to deal with the pain of language interoperability. Hopefully<br>
this will increase programmer productivity.</li>
<li>Several languages already have optional type annotations, but<br>
surprisingly, there had been little formal work on what a type<br>
checker should do with the optional type annotations and what kind<br>
of guarantees the type system should provide. Languages with<br>
optional type annotations include Common LISP, Dylan, Cecil, Visual<br>
Basic.NET, Bigloo Scheme, Strongtalk. Gradual typing is meant to<br>
provide a foundation for what these languages do with their optional<br>
type annotations. There are several new languages in development<br>
that will also include optional type annotations such as Python 3k,<br>
the next version of Javascript (ECMAScript 4), and Perl 6. Hopefully<br>
our work on gradual typing will influence these languages.</li>
</ul>
<p>Before describing gradual typing, let’s review dynamic and static type checking.</p>
<h3>Dynamic type checking</h3>
<p>A number of popular languages, especially scripting languages, are<br>
dynamically typed. Examples include Perl, Python, Javascript, Ruby,<br>
and PHP. In general, a <em>type</em> is something that describes a set<br>
of values that have a bunch of operations in common. For example, the<br>
type <tt>int</tt> describes the set of (usually 32 bit) numbers that<br>
support operations like addition, subtraction, etc. A <em>type<br>
error</em> is the application of an operation to a value of the wrong<br>
type. For example, applying concatenation to an integer would be a<br>
type error in a language where concatenation is an operation only on<br>
strings. Another example of a type error is invoking a method on an<br>
object that doesn’t implement the method, such as<br>
<tt>car.fly()</tt>. (Isn’t it a shame that flying cars have not yet<br>
hit the mainstream, and it’s well past the year 2000!)<br>
The precise definition of <em>type error</em> is programming language<br>
dependent. For example, one language might choose to allow<br>
concatenation of integers and another language not. In a dynamically<br>
typed language, type checking is performed during program execution,<br>
immediately before the application of each operation, to make sure that<br>
the operand type is suitable for the operation.</p>
<p>The following is an example Python program that results in a type error.</p>
<pre>  def add1(x):
      return x + 1

  class A(object):
      pass

  a = A()
  add1(a)</pre>
<p>The output from running the above program on the standard Python<br>
interpreter is</p>
<pre>TypeError: unsupported operand type(s) for +: 'A' and ‘int'</pre>
<h3>Static type checking</h3>
<p>There are also a number of popular statically checked languages, such as Java, C#,<br>
C and C++. In a statically checked language, some or even all type errors<br>
are caught by a type checker prior to running the program. The type<br>
checker is usually part of the compiler and is automatically run<br>
during compilation.</p>
<p>Here’s the above example adapted to Java.</p>
<pre>  class A {
      int add1(int x) {
	  return x + 1;
      }
      public static void main(String args[]) {
	  A a = new A();
	  add1(a);
      }
  }</pre>
<p>When you compile this class, the Java compiler prints out<br>
the following message.</p>
<pre>  A.java:9: add1(int) in A cannot be applied to (A)
          add1(a);
          ^
  1 error</pre>
<p>You may wonder, how can a type checker predict that a type error will<br>
occur when a particular program is run? The answer is that it can’t.<br>
It is impossible to build a type checker that can predict in general which<br>
programs will result in type errors and which will not. (This is<br>
equivalent to the well-known halting problem.) Instead, all type<br>
checkers make a conservative approximation of what will happen during<br>
execution and give error messages for anything that <em>might</em> cause a type<br>
error. For example, the Java compiler rejects the following program<br>
even though it would not actually result in a type error.</p>
<pre>  class A {
      int add1(int x) {
	  return x + 1;
      }
      public static void main(String args[]) {
	  A a = new A();
          if (false)
  	      add1(a);
          else
              System.out.println("Hello World!");
      }
  }</pre>
<p>The Java type checker does not try to figure out which branch of<br>
an <tt>if</tt> statement will be taken at runtime. Instead it<br>
conservatively assumes that either branch could be taken and<br>
therefore checks both branches.</p>
<h3>Comparing dynamic and static type checking</h3>
<p>There is a religious war between people who think dynamic<br>
checking is better and people who think static type checking is better. I<br>
believe that one of the reasons why this war has gone on for so long<br>
is that both groups have good points. (They also have some not-so-good<br>
points.) Unfortunately the two groups typically don’t acknowledge the good points<br>
made by the other group as being good points. My evaluation of the<br>
points, given below, will probably annoy both the static typing<br>
fans and the dynamic typing fans. There are of course arguments to be<br>
made for or against each of the points, and the evaluation below shows where<br>
I land after considering the arguments.</p>
<ul>
<li>Static type checking catches bugs earlier, thereby removing the greater cost of fixing<br>
bugs later in the development cycle or the even greater cost of a bug that occurs<br>
in the field. <b>Good point!</b> Fans of dynamic typing will argue that you catch<br>
even more bugs by creating a thorough test suite for your programs. Nevertheless,<br>
I believe static type checking provides a convenient and low-cost way to catch type errors.</li>
<li>Dynamic type checking doesn’t get in your way: you can immediately run your program<br>
without first having to change your program into a form that the type checker will accept.<br>
<b>Good point!</b> Fans of static typing will argue that either 1) you don’t really<br>
need to change your program very much, or 2) by changing your program to fit<br>
the type checker, your program will become better structured. The reason why 1)<br>
feels true to some programmers is that the language you use changes how you think about<br>
programming and implicitly steers you towards writing programs that will type check in whatever<br>
language you are using. Also, you get so use to working around the minor annoyances<br>
of the type system that you forget that they are annoyances and instead become<br>
proud of your ability to workaround the type system. As for 2), there are<br>
situations in which the type system gets in the way of expressing code in its<br>
most clear and reusable form. The well-known<br>
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">Expression Problem</a> is a good example<br>
of this. The reason why research on type systems continues to flourish is that it<br>
is difficult to design and implement a type system that is expressive enough<br>
to enable the straightforward expression of all programs that we would like to write.</li>
<li>Static type checking enables faster execution because type checking need not be performed<br>
at runtime and because values can be stored in more efficient representations. <b>Good point!</b></li>
<li>Dynamic type checking makes it easy to deal with situations where the type of a value depends<br>
on runtime information. <b>Good point!</b></li>
<li>Static typing improves modularity. <b>Good point!</b> For example, in a dynamic language, you can<br>
call a library subroutine incorrectly but then get a type error deep inside that routine.<br>
Static checking catches the type errors up-front, at the point where you called<br>
the subroutine.</li>
<li>Static type checking makes you think more seriously about your program<br>
which helps to further reduce bugs. <b>Bad point.</b> Type checkers only check fairly<br>
simple properties of your program. Most of the work in making sure that your<br>
program is correct, whether written in a statically or dynamically checked language,<br>
goes into developing comprehensive tests.</li>
<li>With dynamic type checking, you don’t have to spend time writing type annotations.<br>
<b>Bad point.</b> The time it takes to write down a type annotation is rather trivial<br>
and there are programs called type inferencers that can do type checking without<br>
requiring type annotations.</li>
</ul>
<p>Because neither static or dynamic type checking is universally better than the other,<br>
it makes sense to provide the programmer a choice, without forcing them to switch programming<br>
languages. This brings us to gradual typing.</p>
<h3>Gradual type checking</h3>
<p>A <em>gradual type checker</em> is a type checker that checks, at compile-time, for<br>
type errors in some parts of a program, but not others, as directed by which parts<br>
of the program have been annotated with types. For example, our prototype gradual<br>
type checker for Python does not give an error for the above program, reproduced<br>
again below.</p>
<pre>  def add1(x):
      return x + 1

  class A:
      pass

  a = A()
  add1(a)</pre>
<p>However, if the programmer adds a type annotation for the parameter <tt>x</tt>,<br>
as follows, then the type checker signals an error because the type<br>
of variable <tt>a</tt> is <tt>A</tt>, which is inconsistent with<br>
the type of parameter <tt>x</tt> of the <tt>add1</tt> function,<br>
which is <tt>int</tt>.</p>
<pre>  def add1(x : int):
      return x + 1

  class A:
      pass

  a = A()
  add1(a)</pre>
<p>(Our rules for assigning static types to local variables such as <tt>a</tt><br>
are somewhat complicated because Python does not have local variable declarations<br>
but in most cases we give the variable the same type as the expression<br>
on the right-hand side of the assignment.)</p>
<p>The gradual type checker deals with unannotated variables by giving<br>
them the unknown type (also called the <em>dynamic</em> type in the<br>
literature), which we abbreviate as<br>
“<tt>?</tt>” and by allowing implicit conversions from any type<br>
to <tt>?</tt> and also from <tt>?</tt> to any other type. For simplicity, suppose the<br>
<tt>+</tt> operator expects its arguments to be integers. The<br>
following version of <tt>add1</tt> is accepted by the gradual type<br>
checker because we allow an implicit conversion from <tt>?</tt> (the type of<br>
<tt>x</tt>) to <tt>int</tt> (the type expected by <tt>+</tt>).</p>
<pre>  def add1(x):
      return x + 1</pre>
<p>Allowing the implicit converson from <tt>?</tt> to <tt>int</tt> is unsafe,<br>
and is what gives gradual typing the flavor of dynamic typing.<br>
Just as with dynamic typing, the argument bound to<br>
<tt>x</tt> will be checked at run-time to make sure it is an integer before<br>
the addition is performed.</p>
<p>As mentioned above, the gradual type checker also allows implicit conversions<br>
from any type to type <tt>?</tt>. For example, the gradual type checker<br>
accepts the following call to <tt>add1</tt> because it allows the<br>
implicit conversion from <tt>int</tt> (the type of <tt>3</tt>) to <tt>?</tt><br>
(the implied type annotation for parameter <tt>x</tt>).</p>
<pre>  add1(3)</pre>
<p>The gradual type checker also allows implicit conversions between more<br>
comlicated types. For example, in the following program we have a conversion<br>
between different tuple types, from <tt>? * int</tt> to <tt>int * int</tt>.</p>
<pre>  def g(p : int * int):
    return p[0]

  def f(x, y : int):
    p = (x,y)
    g(p)</pre>
<p>In general, the gradual type checker allows an implicit conversion between<br>
two types if they are <em>consistent</em> with each other. We use the shorthand<br>
<tt>S ~ T</tt> to express that type <tt>S</tt> is consitent with type <tt>T</tt>.<br>
Here are some of the rules that define when two types are consistent:</p>
<ol>
<li>For any type <tt>T</tt>, we have both <tt>? ~ T</tt> and <tt>T ~ ?</tt>.</li>
<li>For any basic type <tt>B</tt>, such as <tt>int</tt>, we have <tt>B ~ B</tt>.</li>
<li>A tuple type <tt>T1 * T2</tt> is consitent with another tuple type <tt>S1 * S2</tt><br>
if <tt>T1 ~ S1</tt> and <tt>T2 ~ S2</tt>. This rule generalizes in a straightforward<br>
way to tuples of arbitrary size.</li>
<li>A function type <tt>fun(T1,...,Tn,R)</tt> (the <tt>T1</tt>…<tt>Tn</tt> are the parameter<br>
types and <tt>R</tt> is the return type) is consistent with another function type<br>
<tt>fun(S1,...,Sn,U)</tt> if <tt>T1 ~ S1</tt>…<tt>Tn ~ Sn</tt> and <tt>R ~ U</tt>.</li>
</ol>
<p>We write <tt>S !~ T</tt> when <tt>S</tt> is not consistent with <tt>T</tt>.</p>
<p>So, for example</p>
<ul>
<li><tt>int ~ int</tt></li>
<li><tt>int !~ bool</tt></li>
<li><tt>? ~ int</tt></li>
<li><tt>bool ~ ?</tt></li>
<li><tt>int * int ~ ?</tt></li>
<li><tt>fun(?,?) ~ fun(int,int)</tt></li>
<li><tt>? ~ fun(int,int)</tt></li>
<li><tt>int * int !~ ? * bool</tt></li>
</ul>
<h3>Why subtyping alone does not work</h3>
<p>Gradual typing allows an implicit up-cast from any type to <tt>?</tt>,<br>
similar to object-oriented type systems where Object is the<br>
top of the subtype lattice. However, gradual typing differs in that<br>
it also allows implicit down casts. This is the distinguishing<br>
feature of gradual typing and is what gives it the flavor of dynamic<br>
typing. Previous attempts at mixing static and dynamic typing, such<br>
as Thatte’s <a href="http://doi.acm.org/10.1145/96709.96747">Quasi-static Typing</a>,<br>
tried to use subtyping but had to deal with the following problem. If the dynamic<br>
type is treated as both the top and the bottom of the subtype lattice<br>
(allowing both implicit up-casts and down-casts), then the lattice<br>
collapses to one point because subtyping is transitive. In other<br>
words, every type is a subtype of every other type and the type system<br>
no longer rejects any program, even ones with obvious type errors.</p>
<p>Consider the following program.</p>
<pre>  def add1(x : int) -&gt; int:
     return x + 1
  add1(true)</pre>
<p>Using <tt>true</tt> as an argument to the function <tt>add1</tt> is an obvious type error but we have <tt>bool &lt;: ?</tt> and <tt>? &lt;: int</tt>, so <tt>bool &lt;: int</tt>. Thus the subtype-based type system would accept this program. Thatte partially addressed this problem by adding a post-pass, called plausibility checking, after the type checker but this still did not result in a system that catches all type errors within fully annotated code, as pointed out by <a href="http://portal.acm.org/citation.cfm?id=859857&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=32834670&amp;CFTOKEN=62741019">Oliart</a>. I won’t go into the details of Thatte’s plausibility checking, as it is rather complicated, but I will discuss an example. The following program has an obvious static type error which is not detected by plausibility checking.</p>
<pre>def inc(x: number):
   return x + 1

inc(True)
</pre>
<p>In the application of <tt>inc</tt> to <tt>True</tt>, both <tt>inc</tt> and <tt>True</tt> can be implicitly up-cast to the dynamic type <tt>?</tt>. Then <tt>inc</tt> is implicitly down-cast to <tt>? -&gt; ?</tt>. The plausibility checker looks for a greatest lower bound of <tt>number -&gt; number</tt> and <tt>? -&gt; ?</tt>, which is <tt>? -&gt; number</tt>, so it lets this program pass without warning.</p>
											</div><!-- .entry-content -->

					<div id="entry-author-info">
						<div id="author-avatar">
							<img alt="" src="./What is Gradual Typing _ Jeremy Siek_files/b48042450d277f263ac1444795458a70" srcset="http://2.gravatar.com/avatar/b48042450d277f263ac1444795458a70?s=120&amp;d=blank&amp;r=g 2x" class="avatar avatar-60 photo" height="60" width="60">						</div><!-- #author-avatar -->
						<div id="author-description">
							<h2>About jsiek</h2>
							Jeremy is an Associate Professor in Computer Science at Indiana University Bloomington. 
He teaches courses in programming languages, compilers, and other areas of computer science. Jeremy designs new programming language features to make life easier for programmers who create and use software libraries.							<div id="author-link">
								<a href="http://wphomes.soic.indiana.edu/jsiek/author/jsiek/" rel="author">
									View all posts by jsiek <span class="meta-nav">→</span>								</a>
							</div><!-- #author-link	-->
						</div><!-- #author-description -->
					</div><!-- #entry-author-info -->

					<div class="entry-utility">
						This entry was posted in <a href="http://wphomes.soic.indiana.edu/jsiek/category/blog/" rel="category tag">Blog</a>. Bookmark the <a href="./What is Gradual Typing _ Jeremy Siek_files/What is Gradual Typing _ Jeremy Siek.html" title="Permalink to What is Gradual Typing" rel="bookmark">permalink</a>.											</div><!-- .entry-utility -->
				</div><!-- #post-## -->

				<div id="nav-below" class="navigation">
					<div class="nav-previous"><a href="http://wphomes.soic.indiana.edu/jsiek/keynote-at-tfp-2013/" rel="prev"><span class="meta-nav">←</span> Keynote at TFP 2013</a></div>
					<div class="nav-next"></div>
				</div><!-- #nav-below -->

				
			<div id="comments">



				<div id="respond" class="comment-respond">
			<h3 id="reply-title" class="comment-reply-title">Leave a Reply <small><a rel="nofollow" id="cancel-comment-reply-link" href="http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/#respond" style="display:none;">Cancel reply</a></small></h3><p class="must-log-in">You must be <a href="http://wphomes.soic.indiana.edu/jsiek/wp-login.php?redirect_to=http%3A%2F%2Fwphomes.soic.indiana.edu%2Fjsiek%2Fwhat-is-gradual-typing%2F">logged in</a> to post a comment.</p>		</div><!-- #respond -->
		
</div><!-- #comments -->


			</div><!-- #content -->
		</div><!-- #container -->


		<div id="primary" class="widget-area" role="complementary">
			<ul class="xoxo">


			<li id="search" class="widget-container widget_search">
				<form role="search" method="get" id="searchform" class="searchform" action="http://wphomes.soic.indiana.edu/jsiek/">
				<div>
					<label class="screen-reader-text" for="s">Search for:</label>
					<input type="text" value="" name="s" id="s">
					<input type="submit" id="searchsubmit" value="Search">
				</div>
			</form>			</li>

			<li id="archives" class="widget-container">
				<h3 class="widget-title">Archives</h3>
				<ul>
						<li><a href="http://wphomes.soic.indiana.edu/jsiek/2014/03/">March 2014</a></li>
	<li><a href="http://wphomes.soic.indiana.edu/jsiek/2013/06/">June 2013</a></li>
				</ul>
			</li>

			<li id="meta" class="widget-container">
				<h3 class="widget-title">Meta</h3>
				<ul>
										<li><a href="http://wphomes.soic.indiana.edu/jsiek/wp-login.php">Log in</a></li>
									</ul>
			</li>

					</ul>
		</div><!-- #primary .widget-area -->

	</div><!-- #main -->

	<div id="footer" role="contentinfo">
		<div id="colophon">



			<div id="site-info">
				<a href="http://wphomes.soic.indiana.edu/jsiek/" title="Jeremy Siek" rel="home">
					Jeremy Siek				</a>
			</div><!-- #site-info -->

			<div id="site-generator">
								<a href="https://wordpress.org/" title="Semantic Personal Publishing Platform">Proudly powered by WordPress.</a>
			</div><!-- #site-generator -->

		</div><!-- #colophon -->
	</div><!-- #footer -->

</div><!-- #wrapper -->

<script type="text/javascript" src="./What is Gradual Typing _ Jeremy Siek_files/comment-reply.min.js"></script>
<script type="text/javascript" src="./What is Gradual Typing _ Jeremy Siek_files/jquery.form.min.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
var _wpcf7 = {"loaderUrl":"http:\/\/wphomes.soic.indiana.edu\/jsiek\/wp-content\/plugins\/contact-form-7\/images\/ajax-loader.gif","recaptchaEmpty":"Please verify that you are not a robot.","sending":"Sending ..."};
/* ]]> */
</script>
<script type="text/javascript" src="./What is Gradual Typing _ Jeremy Siek_files/scripts.js"></script>
<script type="text/javascript" src="./What is Gradual Typing _ Jeremy Siek_files/wp-embed.min.js"></script>


</body></html>