\documentclass[preprint,authoryear,sort&compress,9pt,nocopyrightspace]{article}

\usepackage{mathtools}
\usepackage{verbatim} % comentarios
\usepackage{definitions}
\usepackage{comment}

\newcommand\rulename[1]{\mathsf{(#1)}}
\newcommand{\nothing}{\varnothing} % different from \emptyset
\newcommand{\tto}{\longrightarrow}
\newcommand{\lto}{\leftarrow}

\newcommand{\conf}[2][s]{(#2)[#1]}
\newcommand{\confxu}[1]{#1 [x,\{v\}:s]}
\newcommand{\confxD}[1]{#1 [\subxD]}
\newcommand{\confx}[1]{#1 [\SubxD]}
\newcommand{\confxW}[1]{#1 [\SubxDW]}
\newcommand{\confy}[1]{#1 [\SubyD]}
\newcommand{\confyW}[1]{#1 [\SubyDW]}
\newcommand{\confext}[1]{#1 [x \mapsto v \oplus s]}
\newcommand{\confextW}[1]{#1 [x \mapsto w \oplus s]}

\newcommand{\subx}{x \mapsto \{\overline{v}\},s}
\newcommand{\subxD}{x \mapsto \{\overline{v}\},s}
\newcommand{\SubxD}{x \mapsto \{\overline{v}\},s}
\newcommand{\SubxDW}{x \mapsto w,s}
\newcommand{\SubyD}{y \mapsto \{\overline{v}\},s}
\newcommand{\SubyDW}{y \mapsto w,s}
\newcommand{\Subx}{x \mapsto \{\overline{v}\},s'}
\newcommand{\Suby}{y \mapsto \{\overline{v}\},s'}
%\nevcommand{\subx}{[x,(v:T_1):s']}
%\nevcommand{\suby}{[y,(v:T_1):s']}


\newcommand{\subxDT}{x \mapsto \{(\overline{v:T})\},s}
\newcommand{\confxDT}[1]{#1 [\subxD]}

\newcommand{\tyC}{{\Gamma \vdash_c \ }}
\newcommand{\env}{{\Gamma ; \emt   \vdash \ }}

\newcommand{\envE}{{\Gamma , x:T_1  ; \emt \vdash \ }}
\newcommand{\enve}{{\Gamma ; \emt  \oplus (x : T_1)  \vdash \ }}

\newcommand{\envC}{{\Gamma ; \emt(s) \vdash \ }}
\newcommand{\envEC}{{\Gamma , x:T_1 ; \emt(s) \vdash \ }}
\newcommand{\enveC}{{\Gamma ;  \emt(s) \oplus (x : T_1) \vdash \ }}


\newcommand{\ascrip}[1]{#1::T}
\newcommand{\ascripS}[1]{#1::S}
\newcommand{\ascripP}[2]{#1::#2}
\newcommand{\oletD}{\mathsf{mlet} \ x = t \ \mathsf{in}  \ t}
\newcommand{\olet}{\mathsf{mlet} \ x = t_1 \ \mathsf{in}  \ t_2}
\newcommand{\oletP}[3]{\mathsf{mlet} \ x = #2 \ \mathsf{in}  \ #3}
\newcommand{\app}[2]{#1 \ #2}
\newcommand{\appD}{t_1 \ t_2}
\newcommand{\abs}[3]{\lambda #1:#2. \ #3}
\newcommand{\absST}[2]{\lambda #1. \ #2}
\newcommand{\absD}{\lambda x:T_1. \ t_2}
%\nevcommand{\suma}[2]{#1 + #2}
\newcommand{\negacion}[1]{\mathsf{not} \ #1}
\newcommand{\suma}[1]{\mathsf{add1} \ #1}

\newcommand{\oletPT}[3]{\mathsf{mlet} \ x : #1 = #2 \ \mathsf{in}  \ #3}
\newcommand{\absDT}{(\lambda x. \ t_2) ^{T_1 \to T_2}}
\newcommand{\absSTT}[2]{(\lambda #1. \ #2)^{T \to T}}

\newcommand{\lab}{\mathsf{tag}}
\newcommand{\undefmy}{\mathsf{undef}}
\newcommand{\truet}{\mathsf{true}}
\newcommand{\falset}{\mathsf{false}}
\newcommand{\boolt}{\mathsf{Bool}}
\newcommand{\intt}{\mathsf{Int}}
\newcommand{\funt}{\mathsf{Fun}}
\newcommand{\selvt}{\mathsf{selvt}}
\newcommand{\selvv}{\mathsf{selvv}}
\newcommand{\filtrar}{\mathsf{filter}}
\newcommand{\minsel}{\mathsf{minsel}}
\newcommand{\noisin}{\mathsf{noIsIn}}


\newcommand{\tagval}{\mathsf{tagVal}}
\newcommand{\tagtype}{\mathsf{tagType}}
\newcommand{\novalvar}[1]{\mathsf{notVal\_Var}(#1)}
\newcommand{\noval}[1]{\mathsf{notVal}(#1)}
\newcommand{\buscar}{\mathsf{lookup}}
\newcommand{\tipo}{\mathsf{tag}}

\newcommand{\errorA}{\mathsf{error}}
\newcommand{\nameerror}{\mathsf{NameError}}
\newcommand{\typeerror}{\mathsf{TypeError}}
\newcommand{\tagerror}{\mathsf{TagError}}
\newcommand{\dispatcherror}{\mathsf{DispatchError}}
\newcommand{\ambiguityerror}{\mathsf{AmbiguityError}}

\newcommand{\semanticA}{Flexible Language}
\newcommand{\semanticB}{Tag Driven Language}
\newcommand{\semanticC}{Strict Language}
\newcommand{\semanticD}{Overloading Language}

\newcommand{\mtD}{T^{*}}
\newcommand{\mtP}[1]{#1^{*}}
\newcommand{\mtC}[1]{\{\overline {#1}\}}
\newcommand{\mtCu}[1]{\{ #1 \}}

\newcommand{\emt}{\phi}
\newcommand{\conc}{:^{*}}

\newcommand{\tagi}[2]{<#1, #2>}


\newcommand\inferir{\stackrel{\mathclap{\normalfont\mbox{$\to$}}}{\in}}
\newcommand\chequear{\stackrel{\mathclap{\normalfont\mbox{$\lto$}}}{\in}}
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\providecommand{\norm}[1]{\lVert#1\rVert}



\begin{document}
\section{Languages}

\subsection{\semanticA}

\semanticA:
\begin{itemize}
\item Non deterministic semantic, with branches that reduce to a value and other ending in error.
\item Name error detection.
\item Type error detection.
\item Without any type information in the syntax of the language.
\item Uses the explicit substitution. In the case of the $\mathsf{mlet}$ is used the explicit substitution because the implicit substitution of a variable by a value would eliminate the overloading.
\end{itemize} 
Characterization of the errors for \semanticA:

\begin{itemize}
\item Name error is detected if a variable is evaluated in the empty environment.
\item Type error is detected if the operators $\negacion$ or $\suma$ are applied with parameters that are not boolean or numeric value, respectively. Also, if the left side of the function application is not a lambda.
\end{itemize}


\setlength{\topmargin}{-25mm}
\setlength{\textheight}{230mm}
\begin{figure}[h]
\begin{small}
%\begin{table}
\begin{center}
\hspace*{-2cm}
\begin{tabular}{|l|l|}
\hline
\begin{tabular}{l c l r}
&&&\\
$t$&$::=$&&$\mathsf {terms}$\\
&&$b$&$\mathsf {boolean \ value}$\\
&&$n$&$\mathsf {numeric \ value}$\\
&&$op$&$\mathsf{operator}$\\
&&$x$&$\mathsf {variable}$\\
&&$\absST {x}{t}$&\ $\mathsf {abstraction}$\\
&&$\app {t}{t}$&$\mathsf {application}$\\
&&$\oletD$&$\mathsf {overloading \ let}$\\
%&&$\ascrip {t}$&$\mathsf {ascription}$\\
%&&$\suma{t}$&$\mathsf {sum}$\\
%&&$\negacion{t}$&$\mathsf {negation}$\\
&&&\\
$v$&$::=$&&$\mathsf {values}$\\
&&$b$&$\mathsf {boolean \ value}$\\
&&$n$&$\mathsf{numeric \ value} $\\
&&$op$&$\mathsf{operator}$\\
&&$\conf{\absST {x}{t}}$&$\mathsf{closure}$\\
&&&\\
$b$&$::=$&&$\mathsf {boolean \ value}$\\
&&$\truet$&$\mathsf {true \ value}$\\
&&$\falset$&$\mathsf {false \ value}$\\
\end{tabular}
& \begin{tabular}{l c l r}
&&&\\
$op$&$::=$&&$\mathsf {operators}$\\
&&$\suma$&$\mathsf {sum}$\\
&&$\negacion$&$\mathsf{negation} $\\
&&&\\
$c$&$::=$&&$\mathsf {configurations}$\\
&&$v$&\\
&&$t[s]$&\\
&&$c \ c $&\\
&&$\oletP {T}{c}{c}$&\\
&&$e$&\\
&&&\\
$e$&$::=$&&$\mathsf {errors}$\\
&&$\nameerror$&$\mathsf {name \ error}$\\
&&$\typeerror$&$\mathsf {type \ error}$\\
&&&\\
$s$&$::=$&&$\mathsf {explicit \ substitutions}$\\
&&$ \bullet$&$\mathsf {empty \ substitution}$\\
&&$\subx$&$\mathsf {variable \ substitution}$\\
\end{tabular}\\
\hline
\end{tabular}
\hspace*{-2cm}
\caption{Syntax of the \semanticA.}
\label{figure:sintax1}
\end{center}
%\end{table}
\end{small}
\end{figure}

\begin{comment}
\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
&\framebox {$c \tto c$}\\
&\\
%$\truet[s] \tto \truet$&$\rulename{True}  $\\
%&\\
%$\falset[s] \tto \falset$&$\rulename{False}  $\\
$b[s] \tto b$&$\rulename{False}  $\\
&\\
$n[s] \tto n$&$\rulename{Num}  $\\
&\\
$op [s] \tto op$&$\rulename{Op}  $\\
&\\
%$x[ \ ] \tto \mathsf{error}$&$\rulename{ErrVarFail}$\\
%&\\
$\confx{x} \tto v_i$&$\rulename{VarOk}  $\\
&\\
$\inference {x \neq y} {\confy{x} \tto x[s]}$&$\rulename{VarNext}  $\\
%&\\
%$ \conf{\ascrip{t}} \tto \ascrip{t[s]}$&$\rulename{AscSub}$\\
&\\
$ \conf{\olet} \tto \oletP{T_1}{t_1[s]}{t_2[s]}$&$\rulename{LetSub} $\\
&\\
$\conf{\appD} \tto t_1 [s] \ t_2 [s]$&$\rulename{AppSub} $\\
%&\\
%$\conf{\suma{t_1}} \tto \suma{t_1 [s]}$&$\rulename{SumSub} $\\
%&\\
%$\conf{\negacion{t}} \tto \negacion{t [s]}$&$\rulename{NegationSub} $\\
&\\
%$ \ascrip{v} \tto v $&$\rulename{Asc} $\\
%&\\
${\oletP{T_1}{v}{t_2[s]} \tto \confext{t_2}}$&$\rulename{Let} $\\
&\\
$\conf{\absST{x}{t_2}} \ v \tto \conf{[x \mapsto v]{t_2}}$&$\rulename{App}$\\
&\\
$\suma{n} \tto n + 1$&$\rulename{Sum}$\\
&\\
$\negacion{b} \tto \neg \ b $&$\rulename{Negation}$\\
&\\
%$ \inference {c \tto c'}{\ascrip{c} \tto \ascrip{c'} }$&$\rulename{Asc1} $\\
%&\\
$ \inference {c_1 \tto c_1'}{\oletP{T_1}{c_1}{c_2} \tto \oletP{T_1}{c_1'}{c_2} }$&$\rulename{Let1} $\\
&\\
$\inference {c_1 \tto c_1'}{c_1 \ c_2 \tto c_1' \ c_2} $&$\rulename{App1}  $\\
&\\
$ \inference {c \tto c'}{v \ c \tto v \ c'}$&$\rulename{App2}  $\\
&\\
%$\inference {c \tto c'}{op \ c \tto op \ c'} $&$\rulename{OpApp1}  $\\
%$\inference {c_1 \tto c_1'}{\suma{c_1} \tto \suma{c_1'}} $&$\rulename{Sum1}  $\\
%&\\
%$ \inference {c \tto c'}{\suma{v}{c} \tto \suma{v}{c'}}$&$\rulename{Sum2}  $\\
%&\\
%$ \inference {c \tto c'}{\negacion{c} \tto \negacion{c'}}$&$\rulename{Negation1}  $\\
&\\
\hline
\end{tabular}
\caption{Reduction rules for \semanticA.}
\label{tabla:REDUCTIONrULES123}
\end{center}
\end{small}
\end{figure}
\end{comment}

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
&\framebox {$c \tto c$}\\
&\\
$b[s] \tto b$&$\rulename{False}  $\\
&\\
$n[s] \tto n$&$\rulename{Num}  $\\
&\\
$op [s] \tto op$&$\rulename{Op}  $\\
&\\
%$x[ \ ] \tto \mathsf{error}$&$\rulename{ErrVarFail}$\\
%&\\
$\confx{x} \tto v_i$&$\rulename{VarOk}$\\
&\\
$\inference {x \neq y} {\confy{x} \tto x[s]}$&$\rulename{VarNext}  $\\
&\\
%$ \ascrip{v} \tto v $&$\rulename{Asc} $\\
%&\\
${\oletP{T_1}{v}{t_2[s]} \tto \confext{t_2}}$&$\rulename{Let} $\\
&\\
$\conf{\absST{x}{t_2}} \ v \tto \confext{t_2}$&$\rulename{App}$\\
&\\
$\suma{n} \tto n + 1$&$\rulename{Sum}$\\
&\\
$\negacion{b} \tto \neg \ b $&$\rulename{Negation}$\\
&\\
\hline
\end{tabular}
\caption{Reduction rules for \semanticA.}
\label{tabla:rules1}
\end{center}
\end{small}
\end{figure}

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
$ \conf{\olet} \tto \oletP{T_1}{t_1[s]}{t_2[s]}$&$\rulename{LetSub} $\\
&\\
$\conf{\appD} \tto t_1 [s] \ t_2 [s]$&$\rulename{AppSub} $\\
&\\
\hline
\end{tabular}
\caption{Substitution rules for \semanticA.}
\label{tabla:substitutionRules}
\end{center}
\end{small}
\end{figure}

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
%&\\
%&\framebox {$c \tto c$}\\
&\\
$ \inference {c_1 \tto c_1'}{\oletP{T_1}{c_1}{c_2} \tto \oletP{T_1}{c_1'}{c_2} }$&$\rulename{Let1} $\\
&\\
$\inference {c_1 \tto c_1'}{c_1 \ c_2 \tto c_1' \ c_2} $&$\rulename{App1}  $\\
&\\
$ \inference {c_2 \tto c_2'}{v_1 \ c_2 \tto v_1 \ c_2'}$&$\rulename{App2}  $\\
&\\
\hline
\end{tabular}
\caption{Congruence rules for \semanticA.}
\label{tabla:congruenceRules}
\end{center}
\end{small}
\end{figure}

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
%&\\
%&\framebox {$c \tto c$}\\
&\\
$ {\oletP{T_1}{e}{c_2} \tto e  }$&$\rulename{LetErr} $\\
&\\
${e \ c_2 \tto e} $&$\rulename{App1Err}  $\\
&\\
$ {v \ e \tto e}$&$\rulename{App2Err}$\\
&\\
\hline
\end{tabular}
\caption{Propagation error rules for \semanticA.}
\label{tabla:errorRules}
\end{center}
\end{small}
\end{figure}

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
$x[ \ ] \tto \nameerror$&$\rulename{NameError}$\\
&\\
$\inference {v_1 \neq \absST {x}{t} \vee v_1 \neq op}{v_1 \ v_2 \tto \typeerror}$&$\rulename{TypeErrApp}$\\
&\\
$\inference {v \neq n}{\suma{v} \tto \typeerror}$&$\rulename{TypeErrSum}$\\
&\\
$\inference {v \neq b}{\negacion{v} \tto \typeerror }$&$\rulename{TypeErrNegation}$\\
&\\
\hline
\end{tabular}
\caption{Error rules for \semanticA.}
\label{tabla:rules1errors}
\end{center}
\end{small}
\end{figure}


\begin{definition}[$\oplus$]
\label{definition:tcs}
\mbox{}
Given an environment  $s$ and a variable binding $x \mapsto v_1$, the operator $\oplus$ is defined  as follows:
\[ s \oplus x \mapsto v_1 = \begin{cases} 
      x \mapsto \{v_1\}& s =  \varnothing \\
      x \mapsto \{\overline{v}\} \cup \{v_1\}, s' & s = x \mapsto \{\overline{v }\}, s'\\
      y \mapsto \{\overline{v}\}, s' \oplus x \mapsto v_1 & s = y \mapsto \{\overline{v}\}, s'\\
   \end{cases}
\]
\end{definition}




\subsection{\semanticB}
\semanticB:
\begin{itemize}\item Non deterministic semantic, with branches that reduce to a value and other ending in error.
\item name error detection.
\item Type error detection.
\item Dispatch error detection.
\item Without any type information in the syntax of the language.
\item Semantic "tag driven", introducing flat tag.
%\item In the case of n\_place operator, for detecting dispatch error, we need $2^n$ rules, thus is not recommendable. 
\end{itemize}
Characterization of the errors for \semanticB:
\begin{itemize}
\item Name and type error are detected in the same cases that the \semanticA.
\item Dispatch error is detected  if the operators $\negacion$ or $\suma$ are applied with overloaded parameters that do not have instance with tag $\boolt$ or $\intt$ in the environment, respectively. Also, if the left side of the function application is an overloaded variable, but does not exist an instance with tag $\funt$ in the environment.
\end{itemize}


\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|l c l r|}
\hline
$S$&$::=$&&$\mathsf {tags}$\\
&&$\intt$&$\mathsf {integer \ tag}$\\
&&$\boolt$&$\mathsf {boolean \ tag}$\\
&&$\funt$&$\mathsf {function \ tag}$\\
&&&\\
$e$&$::=$&&$\mathsf {errors}$\\
&&$\nameerror$&$\mathsf {name \ error}$\\
&&$\typeerror$&$\mathsf {type \ error}$\\
&&$\dispatcherror$&$\mathsf {dispatch \ error}$\\
$\cdots$&&&\\
\hline
\end{tabular}
\caption{Syntax of the \semanticB.}
\label{figure:syntax2}
\end{center}
\end{small}
\end{figure}


\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
$\cdots$&\\
$\inference{ \buscar(x_1, [s_1],\funt, v_1)}{x_1[s_1] \ v_2 \tto v_1 \ v_2}$&$\rulename{AppVar}$\\
&\\
$\inference{\buscar(x, [s], \intt, n)}{\suma{x[s]} \tto \suma{n}}$&$\rulename{SumVar}$\\
&\\
$\inference{\buscar(x, [s], \boolt, b)}{\negacion{x[s]} \tto \negacion \ b}$&$\rulename{NegationVar}$\\
\hline
\end{tabular}
\caption{Reduction rules for \semanticB.}
\label{tabla:reductionRules2}
\end{center}
\end{small}
\end{figure}

\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
$ \inference {c_1 \tto c_1' & \noval{c_1}}{\oletP{T_1}{c_1}{c_2} \tto \oletP{T_1}{c_1'}{c_2} }$&$\rulename{Let1} $\\
&\\
$\inference {c_1 \tto c_1' & \novalvar{c_1}}{c_1 \ c_2 \tto c_1' \ c_2} $&$\rulename{App1}  $\\
&\\
$ \inference {c_2 \tto c_2' & \noval{c}}{\conf{\absST{x}{t_2}} \ c_2 \tto \conf{\absST{x}{t_2}} \ c'}$&$\rulename{App2}  $\\
&\\
$ \inference {c_2 \tto c_2' & \noval{c_2}}{x[s] \ c_2 \tto x[s] \ c_2'}$&$\rulename{App3}  $\\
&\\
$ \inference {c_2 \tto c_2' & \novalvar{c_2}}{op \ c_2 \tto op \ c_2'}$&$\rulename{App4}  $\\
\hline
\end{tabular}
\caption{Congruence rules for \semanticB.}
\label{tabla:congruenceRules2}
\end{center}
\end{small}
\end{figure}


\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
$\cdots$&\\
$\inference{ \noisin(x_1, [s_1])}{x_1[s_1] \ v_2 \tto  \nameerror}$&$\rulename{NameErrApp}$\\
&\\
$\inference{ \noisin(x, [s])}{\suma{x[s]} \tto \nameerror}$&$\rulename{NameErrSum}$\\
&\\
$\inference{ \noisin(x, [s])}{\negacion{x[s]} \tto \nameerror}$&$\rulename{NameErrNegation}$\\
&\\
$\inference{ \neg \buscar(x_1, [s_1],\funt, v_1)}{x_1[s_1] \ v_2 \tto  \dispatcherror}$&$\rulename{DisErrApp}$\\
&\\
$\inference{\neg \buscar(x, [s], \intt, n)}{\suma{x[s]} \tto \dispatcherror}$&$\rulename{DisErrSum}$\\
&\\
$\inference{\neg \buscar(x, [s], \boolt, b)}{\negacion{x[s]} \tto \dispatcherror}$&$\rulename{DisErrNegation}$\\
\hline
\end{tabular}
\caption{Error rules for \semanticB.}
\label{tabla:errorRules2}
\end{center}
\end{small}
\end{figure}

\begin{definition}[$\buscar$]
\label{definition:tcs}
\mbox{}
The relation $\buscar$ is defined  as follows:
\[ \buscar  = \{(x, s, S, v)| x \mapsto v \in \mathsf{flat}(s) \wedge \lab(v) = S\}
\]
\end{definition}

\begin{definition}[$\mathsf{flat}$]
\label{definition:tcs}
\mbox{}
The function $\mathsf{flat}$ is defined  as follows:
\[ \mathsf{flat}(s) = \begin{cases} 
      \varnothing & s =  \varnothing \\
      x \mapsto v_1 \cdots , x \mapsto v_n,\mathsf{flat} (s') & s = x \mapsto \{\overline{v}\}, s'\\
   \end{cases}
\]
\end{definition}

\begin{definition}[$\lab$]
\label{definition:tcs}
\mbox{}
The function $\lab$ is defined  as follows:
\[ \lab(v) = \begin{cases} 
      \intt & v = n \\
      \boolt & v = b \\
      \funt & v = \absST{x}{t} \vee v = op\\
   \end{cases}
\]
\end{definition}







\subsection{\semanticB \ with ascription}

\begin{figure}[h]
\begin{small}
\begin{center}
\hspace*{-2cm}
\begin{tabular}{|l c l r|}
\hline
$\cdots$&&&\\
$t$&$::=$&&$\mathsf {terms}$\\
&&$\cdots$&\\
&&$\ascripS{t}$&$\mathsf {ascription}$\\
&&&\\
$c$&$::=$&&$\mathsf {configurations}$\\
&&$\cdots$&\\
&&$\ascripS{c}$&\\
\hline
\end{tabular}
\hspace*{-2cm}
\caption{Syntax of the \semanticB \ with ascriptions.}
\label{figure:SYNTAXASCRIP}
\end{center}
\end{small}
\end{figure}


\begin{figure}[h]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
&\framebox {$c \tto c$}\\
$\cdots$&\\
$ \inference {\lab(v) = S}{\ascripS{v} \tto v} $&$\rulename{Asc} $\\
&\\
$ \conf{\ascripS{t}} \tto \ascripS{t[s]}$&$\rulename{AscSub}$\\
&\\
$ \inference{\buscar(x, [s], S, v)}{\ascripS{x[s]} \tto  v} $&$\rulename{AscVar}$\\
&\\
$ \inference {c \tto c' & \novalvar{c}}{\ascripS{c} \tto \ascripS{c'} }$&$\rulename{Asc1} $\\
&\\
$ {\ascripS{error} \tto error }$&$\rulename{AscErr} $\\
&\\
$ \inference {\noisin(x, [s])}{\ascripS{x[s]} \tto \nameerror} $&$\rulename{NameErrAsc} $\\
&\\
$ \inference {\lab(v) \neq S}{\ascripS{v} \tto \typeerror} $&$\rulename{TypeErrAsc} $\\
&\\
$ \inference{\neg\buscar(x, [s], S, v)}{\ascripS{x[s]} \tto  v} $&$\rulename{DisErrAsc}$\\
&\\
\hline
\end{tabular}
\caption{Rules for \semanticB  \ with ascriptions.}
\label{tabla:rulesascrip}
\end{center}
\end{small}
\end{figure}



\subsection{\semanticC}


\semanticC:
\begin{itemize}\item Deterministic semantic. With the use of multi-values a program can reduce to a set of value.
\item Name error detection.
\item Type error detection.
\item Dispatch error detection.
\item Ambiguity error detection.
\end{itemize}
Characterization of the errors for \semanticC:
\begin{itemize}
\item Free variable and type error are detected in the same cases that the \semanticB \ with ascription.
\item Ambiguity error is detected if the left side of the function application  have more than one instance with $\funt$ tag or in the right side have more than one value for the application. Strict detection of ambiguity. 
\end{itemize}

\begin{figure}[]
\begin{small}
%\begin{table}
\begin{center}
\hspace*{-2cm}
\begin{tabular}{|l c l r|}
\hline
&&$\cdots$&\\
$w$&$::=$&&$\mathsf {multi-value}$\\
&&$v$&$\mathsf {value}$\\
&&$\{\overline{v}\}$&$\mathsf {set \ of \ values}$\\
&&&\\
$c$&$::=$&&$\mathsf {configurations}$\\
&&$w$&\\
&&$t[s]$&\\
&&$c \ c $&\\
&&$\oletP {T}{c}{c}$&\\
&&$\ascripS{c}$&\\
&&$e$&$\mathsf {error}$\\
&&&\\
$s$&$::=$&&$\mathsf {explicit \ substitutions}$\\
&&$ \bullet$&$\mathsf {empty \ substitution}$\\
&&$x \mapsto w, s$&$\mathsf {variable \ substitution}$\\
&&&\\
$e$&$::=$&&$\mathsf {errors}$\\
&&$\cdots$&\\
%&&$\nameerror$&$\mathsf {name \ error}$\\
%&&$\typeerror$&$\mathsf {type \ error}$\\
%&&$\dispatcherror$&$\mathsf {dispatch \ error}$\\
&&$\ambiguityerror$&$\mathsf {ambiguity \ error}$\\
\hline
\end{tabular}
\hspace*{-2cm}
\caption{Syntax of the \semanticC.}
\label{figure:SYNTAX4}
\end{center}
%\end{table}
\end{small}
\end{figure}

\begin{figure}[]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
&\framebox {$c \tto c$}\\
&\\
$b[s] \tto b$&$\rulename{False}  $\\
&\\
$n[s] \tto n$&$\rulename{Num}  $\\
&\\
$op [s] \tto op$&$\rulename{Op}  $\\
&\\
$\{\overline{v}\} [s] \tto \{\overline{v}\} $&$\rulename{MultiValue}  $\\
&\\
$\confxW{x} \tto w$&$\rulename{VarOk}  $\\
&\\
$\inference {x \neq y} {\confyW{x} \tto x[s]}$&$\rulename{VarNext}  $\\
&\\
$ \inference {\filtrar(w, S) = w' & w' \neq \emptyset} {\ascripS{w} \tto w'} $&$\rulename{Asc} $\\
&\\
${\oletP{T_1}{w}{t_2[s]} \tto \confextW{t_2}}$&$\rulename{Let} $\\
&\\
${(\absST{x}{t_2})[s] \ w \tto \confextW{t_2}}$&$\rulename{App}$\\
&\\
$\inference{ \filtrar(\{\overline{v}\} , \funt) = \{v_1\}}{\{\overline{v}\} \ w_2 \tto v_1 \ w_2}$&$\rulename{AppMultValue}$\\
&\\
$\inference {\filtrar(w, \intt)  = \{\overline{n}\} }{\suma{w} \tto \{ \overline{n + 1} \}}$&$\rulename{Sum}$\\
&\\
$\inference {\filtrar(w, \boolt)  = \{\overline{b}\} }{\negacion{w}\tto {\{ \overline{\neg \ b} \}}}$&$\rulename{Negation}$\\

&\\
\hline
\end{tabular}
\caption{Reduction rules for \semanticC.}
\label{tabla:reductionRulesStrict}
\end{center}
\end{small}
\end{figure}

The only rule that change is:
$ \inference {c \tto c'}{w \ c \tto w \ c'}$ $\rulename{App2}  $\\

\begin{figure}[]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
$ \inference {\filtrar(w, S) = \{v\}} {\ascripS{w} \tto v } $&$\rulename{Asc} $\\
&\\
%${\oletP{T_1}{w}{t_2[s]} \tto \confextW{t_2}}$&$\rulename{Let} $\\
%&\\
%$\inference{((\absST{x}{t_2})[s], v_2) = \buscar(w_1, w_2)}{w_1 \ w_2 \tto \conf{[x \mapsto v_2]{t_2}}}$&$\rulename{App}$\\
%$\inference{\filtrar(w_1, \funt) = \{\absST{x}{t_2} \}}{w_1 \ w_2 \tto \conf{[x \mapsto w_2]{t_2}}}$&$\rulename{App}$\\
%&\\
$\inference {\filtrar(w, \intt)  = \{n\} }{\suma{w} \tto n + 1}$&$\rulename{Sum}$\\
&\\
$\inference {\filtrar(w, \boolt)  = \{b\} }{\negacion{w}\tto {\neg \ b}}$&$\rulename{Negation}$\\

&\\
\hline
\end{tabular}
\caption{Reduction rules for \semanticC.}
\label{tabla:reductionRulesStrictMore}
\end{center}
\end{small}
\end{figure}

\begin{figure}[]
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
$\cdots$&\\
$ \inference {\filtrar(\{\overline{v}\}, S) = \{\ \}} {\ascripS{\{\overline{v}\}} \tto \dispatcherror} $&$\rulename{DisErrAsc} $\\
%&\\
%${\oletP{T_1}{w}{t_2[s]} \tto \confextW{t_2}}$&$\rulename{DisErrLet} $\\
&\\
%$\inference{((\absST{x}{t_2})[s], v_2) = \buscar(w_1, w_2)}{w_1 \ w_2 \tto \conf{[x \mapsto v_2]{t_2}}}$&$\rulename{App}$\\

$\inference{ \filtrar(\{\overline{v}\}, \funt) = \{ \ \}}{\{\overline{v}\} \ w_2 \tto \dispatcherror}$&$\rulename{DisErrApp}$\\
&\\
$\inference {\filtrar(\{\overline{v}\}, \intt)  = \{\ \} }{\suma{\{\overline{v}\}} \tto \dispatcherror}$&$\rulename{DisErrSum}$\\
&\\
$\inference {\filtrar(\{\overline{v}\}, \boolt)  = \{ \ \} }{\negacion{\{\overline{v}\}}\tto \dispatcherror}$&$\rulename{DisErrNegation}$\\
&\\

$ \inference {\filtrar(\{\overline{v}\}, S) = w \ \wedge \|w\| > 1} {\ascripS{\{\overline{v}\}} \tto \ambiguityerror} $&$\rulename{AmbErrAsc} $\\
&\\
%${\oletP{T_1}{w}{t_2[s]} \tto \confextW{t_2}}$&$\rulename{AmbErrLet} $\\
%&\\
%$\inference{((\absST{x}{t_2})[s], v_2) = \buscar(w_1, w_2)}{w_1 \ w_2 \tto \conf{[x \mapsto v_2]{t_2}}}$&$\rulename{App}$\\

$\inference{ \filtrar(\{\overline{v}\}, \funt) = w \ \wedge \|w\| > 1}{\{\overline{v}\} \ w_2 \tto \ambiguityerror}$&$\rulename{AmbErrApp}$\\
&\\
$\inference {\filtrar(\{\overline{v}\}, \intt)  = w \ \wedge \|w\| > 1}{\suma{\{\overline{v}\}} \tto \ambiguityerror}$&$\rulename{AmbErrSum}$\\
&\\
$\inference {\filtrar(\{\overline{v}\}, \boolt)  = w \ \wedge \|w\| > 1}{\negacion{\{\overline{v}\}}\tto \ambiguityerror}$&$\rulename{AmbErrNegation}$\\
&\\
\hline
\end{tabular}
\caption{Error rules for \semanticC.}
\label{tabla:errorRulesStrictMore}
\end{center}
\end{small}
\end{figure}





\begin{comment}
\begin{definition}[$\oplus$]
\label{definition:tcs}
\mbox{}
Given an environment  $s$ and a variable binding $x \mapsto v_1$, the operator $\oplus$ is defined  as follows:
\[ s \oplus x \mapsto w = \begin{cases} 
      x \mapsto \{w\}& s =  \varnothing \wedge w = v\\
      x \mapsto w & s =  \varnothing \wedge w \neq v\\
      x \mapsto w' \cup \{w\}, s' & s = x \mapsto w', s' \wedge w = v\\
      x \mapsto w' \cup w, s' & s = x \mapsto w', s' \wedge w \neq v\\
      y \mapsto w', s' \oplus x \mapsto w & s = y \mapsto w', s'\\
   \end{cases}
\]
\end{definition}
\end{comment}

\begin{definition}[$\oplus$]
\label{definition:tcs}
\mbox{}
Given an environment  $s$ and a variable binding $x \mapsto v_1$, the operator $\oplus$ is defined  as follows:
\[ s \oplus_1 x \mapsto w = \begin{cases} 
      x \mapsto w & s =  \varnothing\\
      x \mapsto w' \cup w, s' & s = x \mapsto w', s'\\
      y \mapsto w', s' \oplus x \mapsto w & s = y \mapsto w', s'\\
   \end{cases}
\]

\[ s \oplus_2 x \mapsto w = \begin{cases} 
      x \mapsto w & s =  \varnothing\\
      x \mapsto w' \cup w, s' & s = x \mapsto w', s'\\
      y \mapsto w', s' \oplus_2 x \mapsto w & s = y \mapsto w', s'\\
   \end{cases}
\]
\end{definition}


\begin{definition}[$\filtrar(\cdot, \cdot)$]
\label{definition:tcs}
\mbox{}
The function $\filtrar$ is defined  as follows:
\[ \filtrar(w, S) = \{v| v \in w \wedge \lab(v) = S \}
\]
\end{definition}


\begin{comment}
\begin{definition}[$\buscar$]
\label{definition:tcs}
\mbox{}
The function $\buscar$ is defined  as follows:
 \[ \buscar(w_1, w_2) = (v_1, v_2)  \  !\exists v_1 \in w_1|\lab(v_1) = \funt \ \wedge \ w_2 = \{ v_2 \}
 \]
 \end{definition}
\end{comment}


\begin{comment}
\begin{definition}[$\buscar$]
\label{definition:tcs}
\mbox{}
The function $\buscar$ is defined  as follows:
 \[\buscar(w_1, w_2) = (v_1, w_2)  \  !\exists v_1 \in w_1|\lab(v_1) = \funt\]
 \end{definition}
\end{comment}
 
\subsection{\semanticD}
\begin{itemize}
\item Deterministic semantic. With the use of multi-values a program can reduce to a set of value.
\item Type error detection.
\item Dispatch error detection.
\item Ambiguity error detection.
\item Type annotation in lambda functions, $\mathsf{mlet}$ and ascription.
\item More expressive than \semanticC, with the use structural tags.
\item Do not support context-dependent overloading.
\item Como no esta verificacda la informacion de tipo, no se puede decir nada acerca de la semantica.
\end{itemize}

\begin{figure}
\begin{small}
%\begin{table}
\begin{center}
\hspace*{-2cm}
\begin{tabular}{|l|l|}
\hline
\begin{tabular}{l c l r}
&&&\\
$t$&$::=$&&$\mathsf {terms}$\\
&&$b$&$\mathsf {boolean \ value}$\\
&&$n$&$\mathsf {numeric \ value}$\\
&&$op$&$\mathsf{operator}$\\
&&$\absSTT {x}{t}$&\ $\mathsf {abstraction}$\\
&&$x$&$\mathsf {variable}$\\
&&$\app {t}{t}$&$\mathsf {application}$\\
&&$\oletP{T}{t}{t}$&$\mathsf {overloading \ let}$\\
&&$\ascrip {t}$&$\mathsf {ascription}$\\
%&&$op \ t$&$\mathsf {operator \ application}$\\
%&&$\suma{t}$&$\mathsf {sum}$\\
%&&$\negacion{t}$&$\mathsf {negation}$\\
%&&&\\
%$b$&$::=$&&$\mathsf {boolean \ value}$\\
%&&$\truet$&$\mathsf {true \ value}$\\
%&&$\falset$&$\mathsf {false \ value}$\\
%&&&\\
%$op$&$::=$&&$\mathsf {operators}$\\
%&&$\suma$&$\mathsf {sum}$\\
%&&$\negacion$&$\mathsf{negation} $\\
%&&&\\
$T$&$::=$&&$\mathsf {types}$\\
&&$\intt$&$\mathsf {type \ of \ integers}$\\
&&$\boolt$&$\mathsf {type \ of \ booleans}$\\
&&$T \to T$&$\mathsf {type \ of \ functions}$\\
\end{tabular}
& \begin{tabular}{l c l r}
&&&\\
$v$&$::=$&&$\mathsf {values}$\\
&&$b$&$\mathsf {boolean \ value}$\\
&&$n$&$\mathsf{numeric \ value} $\\
&&$op$&$\mathsf{operator}$\\
&&$\conf{\absSTT {x}{t}}$&$\mathsf{closure}$\\
&&&\\
%$w$&$::=$&&$\mathsf {multi-value}$\\
%%&&$v$&$\mathsf {value}$\\
%&&$\{\overline{v}\}$&$\mathsf {set \ of \ values}$\\
%&&&\\
$c$&$::=$&&$\mathsf {configurations}$\\
&&$w$&\\
&&$t[s]$&\\
&&$c \ c $&\\
&&$\oletPT{T}{c}{c}$&\\
&&$\ascrip{c}$&\\
%&&$\suma{c}$&\\
%&&$\negacion{c}$&\\
%%&&$\mathsf{error}$&\\
%$s$&$::=$&&$\mathsf {explicit \ substitutions}$\\
%&&$ \bullet$&$\mathsf {empty \ substitution}$\\
%&&$\subx$&$\mathsf {variable \ substitution}$\\
%%&&$\subxDT$&$\mathsf {variable \ substitution}$\\
&&&\\
\end{tabular}\\
\hline
\end{tabular}
\hspace*{-2cm}
\caption{Syntax of the \semanticD.}
\label{figure:syntaxoverloading}
\end{center}
%\end{table}
\end{small}
\end{figure}

\begin{figure}
\begin{small}
\begin{center}
\begin{tabular}{|c r|}
\hline
&\\
&\framebox {$c \tto c$}\\
&\\
$w[s] \tto w$&$\rulename{MultiValue}  $\\
&\\
$\confxW{x} \tto w$&$\rulename{VarOk}  $\\
&\\
$\inference {x \neq y} {\confyW{x} \tto x[s]}$&$\rulename{VarNext}  $\\s
&\\
$ \conf{\ascrip{t}} \tto \ascrip{t[s]}$&$\rulename{AscSub}$\\
&\\
$ \conf{\oletPT{T_1}{t_1}{t_2}} \tto \oletPT{T_1}{t_1[s]}{t_2[s]}$&$\rulename{LetSub} $\\
&\\
$\conf{\appD} \tto t_1 [s] \ t_2 [s]$&$\rulename{AppSub} $\\
&\\
%$\conf{\suma{t_1}} \tto \suma{t_1 [s]}$&$\rulename{SumSub} $\\
%&\\
%$\conf{\negacion{t}} \tto \negacion{t [s]}$&$\rulename{NegationSub} $\\
%&\\
$ \inference {\filtrar(w, S) = \{v\}} {\ascrip{w} \tto \{v\}} $&$\rulename{Asc} $\\
&\\
$\inference {\filtrar(w, T_1) = \{v\}}{\oletPT{T_1}{w}{t_2[s]} \tto \confext{t_2}}$&$\rulename{Let} $\\
&\\
$\inference{((\absDT)[s], v_2) = \buscar(w_1, w_2)}{w_1 \ w_2 \tto \conf{[x \mapsto v_2]{t_2}}}$&$\rulename{App}$\\
&\\
$\inference{\filtrar(w, \intt) = \{n\}}{\suma{w} \tto \{n + 1\}}$&$\rulename{Sum}$\\
&\\
$\inference{\filtrar(w, \boolt) = \{b\}}{\negacion{w} \tto \{ \neg \ b \} }$&$\rulename{Negation}$\\
&\\
$ \inference {c \tto c'}{\ascrip{c} \tto \ascrip{c'} }$&$\rulename{Asc1} $\\
 &\\
$ \inference {c_1 \tto c_1'}{\oletP{T_1}{c_1}{c_2} \tto \oletP{T_1}{c_1'}{c_2} }$&$\rulename{Let1} $\\
&\\
$\inference {c_1 \tto c_1'}{c_1 \ c_2 \tto c_1' \ c_2} $&$\rulename{App1}  $\\
&\\
$ \inference {c \tto c'}{v \ c \tto v \ c'}$&$\rulename{App2}  $\\
&\\
\hline
\end{tabular}
\caption{Reduction rules for \semanticD.}
\label{tabla:rulesoverloadingsemantic}
\end{center}
\end{small}
\end{figure}

\begin{comment}
\begin{definition}[$\oplus$]
\label{definition:tcs}
\mbox{}
Given an environment  $s$ and a variable binding $x \mapsto (v_1:T_1)$, the operator $\oplus$ is defined  as follows:
\[ s \oplus x \mapsto (v_1:T_1) = \begin{cases} 
      x \mapsto \{(v_1:T_1)\}& s =  \varnothing \\
      x \mapsto \{(\overline{v : T})\} \cup \{(v_1 : T_1)\}, s' & s = x \mapsto \{(\overline{v : T})\}, s'\\
      y \mapsto \{(\overline{v : T})\}, s' \oplus x \mapsto (v_1:T_1) & s = y \mapsto \{(\overline{v : S})\}, s'\\
   \end{cases}
\]
\end{definition}
\end{comment}

\begin{comment}
\begin{definition}[$\oplus$]
\label{definition:tcs}
\mbox{}
Given an environment  $s$ and a variable binding $x \mapsto v_1$, the operator $\oplus$ is defined  as follows:
\[ s \oplus x \mapsto v_1 = \begin{cases} 
      x \mapsto \{v_1\}& s =  \varnothing \\
      x \mapsto \{\overline{v}\} \cup \{v_1\}, s' & s = x \mapsto \{\overline{v }\}, s'\\
      y \mapsto \{\overline{v}\}, s' \oplus x \mapsto v_1 & s = y \mapsto \{\overline{v}\}, s'\\
   \end{cases}
\]
\end{definition}
\end{comment}

\begin{definition}[$\lab$]
\label{definition:tcs}
\mbox{}
The function $\lab$ is defined  as follows:
\[ \lab(v) = \begin{cases} 
      \intt & v = n \\
      \boolt & v = b \\
      T_1 \to T_2 & v  = (\absDT)[s]\\
   \end{cases}
\]
\end{definition}

\begin{definition}[$\filtrar(\cdot, \cdot)$]
\label{definition:tcs}
\mbox{}
The function $\filtrar$ is defined  as follows:
\[ \filtrar(w, T) = \{
     v | v \in w |\lab(v) = T \}
\]
\end{definition}

\begin{comment}
\begin{definition}[$\mathsf{flat}$]
\label{definition:tcs}
\mbox{}
The function $\mathsf{flat}$ is defined  as follows:
\[ \mathsf{flat}(s) = \begin{cases} 
      \varnothing & s =  \varnothing \\
      x \mapsto (v_1 : T_1) \cdots, x \mapsto (v_n : T_n),\mathsf{flat} (s') & s = x \mapsto \{(\overline{v : T})\}, s'\\
   \end{cases}
\]
\end{definition}
\end{comment}

\begin{comment}
\begin{definition}[$\buscar$]
\label{definition:tcs}
\mbox{}
The function $\buscar$ is defined  as follows:
\[ \buscar(w_1, w_2) = \begin{cases} 
      (w_1, w_2) & w_1 = v_1 \wedge w_2 = v_2\\
      (w_1, v_2) & w_1 = v_1 \wedge \lab(w_1) = T_1 \to T_2 \ \wedge \  ! \exists v_2 \in w_2 |\lab(v_2) = T_1\\
      (v_1, w_2) & w_2 = v_2 \wedge \lab(w_2) = T_1  \ \wedge \  ! \exists v_1 \in w_1 | \mathsf{dom}(\lab(v_1)) = T_1\\
      (v_1, v_2) & ! \exists v_1 \in w_1 \ \wedge \ ! \exists v_2 \in w_2|\lab(v_1) = T_1 \to T_2 \wedge \lab(v_2) = T_1
   \end{cases}
\]
\end{definition}
\end{comment}

\begin{definition}[$\buscar$]
\label{definition:tcs}
\mbox{}
The function $\buscar$ is defined  as follows:
\[ \buscar(w_1, w_2) =  
  \{(v_1, v_2) | v_1 \in w_1 \ \wedge \ v_2 \in w_2 \ \wedge \ \lab(v_1) = T_1 \to T_2 \ \wedge \ \lab(v_2) = T_1\}
\]
\end{definition}



\subsection{Static semantic for \semanticD}



\begin{figure}
\begin{small}
\begin{center}
\begin{tabular}{|l c l r|}
\hline
&$\cdots$&&\\
$\mtP{T}$&$::=$&&$\mathsf {multi-types}$\\
&&$\mtC{T}$&$\mathsf {multi-type}$\\
&&&\\
$\Gamma$&$::=$&&$\mathsf {typing \ contexts}$\\
&&$\varnothing$&$\mathsf {empty \ context}$\\
&&$\Gamma , x:T$&$\mathsf {term \ variable \ binding}$\\
&&&\\
$\emt$&$::=$&&$\mathsf {multi-typing \ contexts}$\\
&&$\varnothing$&$\mathsf {empty \ context}$\\
&&$\emt,x: \mtP{T}$&$\mathsf {term \ variable \ binding}$\\
&&&\\
\hline
\end{tabular}
\caption{Syntax for \semanticD \ with static semantic. }
\label{tabla:syntaxstatic}
\end{center}
\end{small}
\end{figure}



\begin{figure}
\begin{small}
\begin{center}
\hspace*{-3cm}
\begin{tabular}{|l c r|}
\hline
%\multicolumn{2}{l}{$\mathsf {Term \ typing}$}&$\env t:T$\\
&&\framebox {$\env t:T$}\\
&&\\
&$\env  b : \{\boolt\}$&$\rulename{TBool}$\\
&&\\
&$\env  n : \{\intt\}$&$\rulename{TInt}$\\
&&\\
&$\env  \negacion : \{\boolt \to \boolt\}$&$\rulename{TNegation}$\\
&&\\
&$\env  \suma : \{\intt \to \intt\}$&$\rulename{TSum}$\\
&&\\
&$\inference {x:T \in \Gamma}{\env x : \mtCu{T}}$&$\rulename{TVar\Gamma}$\\
&&\\
&$\inference {x:\mtD \in \emt}{\env x : \mtD}$&$\rulename{TVar\emt}$\\
&&\\
&$\inference {x \not \in dom(\Gamma \cup \emt) \\  & \envE t_2:T_2^{*} & T_2 \in T_2^{*}}{\tyC \absDT: \{T_1 \to T_2\}}$&$\rulename{TAbs}$\\
&&\\
&$\inference{\env t : \mtD & T \in  \mtD}{\env \ascrip{t} : \mtCu{T}}$&$\rulename{TAsc}$\\
&&\\
&$\inference{x \not \in dom(\Gamma) & \env t_1 : \mtP{T_1}  & \\ T_1 \in  \mtP{T_1}& \enve t_2 : \mtP{T_2}}{\env \oletPT{T_1}{t_1}{t_2} : \mtP{T_2}}$&$\rulename{TLet}$\\
&&\\
&$\inference {\env t_1 : T_1^{*} & \env t_2 : T_2^{*}  \\ & !\exists(T_1 \to T_2) \in T_1^{*}| !\exists(T_1) \in T_2^{*}}{\env \appD : \{T_2\}}$&$\rulename{TApp}$\\
&&\\
\hline
\end{tabular}
\hspace*{-2.8cm}
\caption{Term typing rules.}
\label{tabla:termtypingrule}
\end{center}

\end{small}
\end{figure}


\begin{figure}
\begin{small}
\begin{center}
\hspace*{-3cm}
\begin{tabular}{|l c r|}
\hline
%\multicolumn{2}{l}{$\mathsf {Term \ typing}$}&$\env t:T$\\
&&\framebox {$\env t:T$}\\
&&\\
&$\tyC  b : \{\boolt\}$&$\rulename{CTBool}$\\
&&\\
&$\tyC  b[s] : \{\boolt\}$&$\rulename{CSTBool}$\\
&&\\
&$\tyC  n : \{\intt\}$&$\rulename{CTInt}$\\
&&\\
&$\tyC  n[s] : \{\intt\}$&$\rulename{CSTInt}$\\
&&\\
&$\tyC  \negacion : \{\boolt \to \boolt\}$&$\rulename{CTNegation}$\\
&&\\
&$\tyC  \negacion[s] : \{\boolt \to \boolt\}$&$\rulename{CSTNegation}$\\
&&\\
&$\tyC  \suma : \{\intt \to \intt\}$&$\rulename{CTSum}$\\
&&\\
&$\tyC  \suma[s] : \{\intt \to \intt\}$&$\rulename{CSTSum}$\\
&&\\
&$\inference {x:T \in \Gamma}{\tyC x[s] : \mtCu{T}}$&$\rulename{CTVar\Gamma}$\\
&&\\
&$\inference {x:\mtD \in \emt(s)}{\tyC x[s] : \mtD}$&$\rulename{CTVar\emt}$\\
&&\\
&$\inference {x \not \in dom(\Gamma \cup \emt(s)) \\  & \Gamma, x : T_1 \vdash_c t_2[s] :T_2^{*} & T_2 \in T_2^{*}}{\tyC (\absDT)[s]: \{T_1 \to T_2\}}$&$\rulename{CTAbs}$\\
&&\\
&$\inference{\tyC t[s] :: T : \mtD }{\tyC (\ascrip{t})[s] : \mtD}$&$\rulename{CTAsc}$\\
&&\\
&$\inference{\tyC c : T^{*} & T \in  \mtD}{\tyC \ascrip{c} : \mtCu{T}}$&$\rulename{CSTAsc}$\\
&&\\
&$\inference{\tyC \oletPT{T_1}{t_1[s]}{t_2[s] : \mtP{T}}}{\tyC \conf{\oletPT{T_1}{t_1}{t_2}} : \mtP{T}}$&$\rulename{CTLet}$\\
&&\\
&$\inference{x \not \in dom(\Gamma) & \tyC c_1 : \mtP{T_1}  & \\ T_1 \in  \mtP{T_1}& \enveC t_2 : \mtP{T_2}}{\tyC \oletPT{T_1}{c_1}{t_2[s]} : \mtP{T_2}}$&$\rulename{CSTLet}$\\
&&\\
&$\inference {\tyC t_1[s] \ t_2[s] : \mtP{T}}{\tyC \conf{\appD} : \mtP{T}}$&$\rulename{CTCApp}$\\
&&\\
&$\inference {\tyC c_1 : T_1^{*} & \tyC c_2 : T_2^{*}  \\ & !\exists(T_1 \to T_2) \in T_1^{*}| !\exists(T_1) \in T_2^{*}}{\tyC c_1 \ c_2 : \{T_2\}}$&$\rulename{CSTApp}$\\
&&\\
\hline
\end{tabular}
\hspace*{-2.8cm}
\caption{Configuration typing rules.}
\label{tabla:confugurationtypingrule}
\end{center}

\end{small}
\end{figure}

\begin{definition}[$\oplus$]
\label{definition:tcs}
\mbox{}
Given a multi-type context $\emt$ and a pair $(x:T)$, the operator $\oplus$ is defined  as follows:
\[ \emt \oplus (x:T) = \begin{cases} 
      x:\mtCu{T}& \emt =  \varnothing \\
      \emt',x:(\mtD \cup \mtCu{T}) & \emt = \emt',x:\mtD\\
      \emt' \oplus (x:T),y:\mtD & \emt = \emt',y:\mtD\\
   \end{cases}
\]
\end{definition}

\begin{definition}[$\Gamma(s)$]
\label{definition:tcs}
\mbox{}
The typing context built from a substitution $s$, writing $\Gamma(s)$, it is defined as follows:
\[ \Gamma(s) = \begin{cases} 
     \varnothing & s =  \bullet \\
      \Gamma(s'), x:T & s = (x,v):s' \ \land \ \tyC v : T 
   \end{cases}
\]
\end{definition}

\end{document}
