 \documentclass[hidelinks, twocolumn]{article}
%\documentclass{article}

\usepackage
[
        a4paper,
        left=2cm,
        right=2cm,
        top=2.5cm,
        bottom=3cm,
]
{geometry}
\usepackage{lipsum}


%%%% Packages
\usepackage{mathtools}
%\usepackage{proof}
%\usepackage{ebproof}
\usepackage{hyperref} %package for generating bookmarks
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{graphicx}
%used for figure, for stopping auto float
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stackengine}
\usepackage{enumerate} 
%Multiline comment
\usepackage{verbatim}
%for logic proofs
%\usepackage{proof}
\usepackage{pdflscape}
% Package that contains captionof
\usepackage{caption}
% Package for code listings
\usepackage{listings}
\lstset{language=ML} 

%\usepackage{color}
\usepackage[usenames, dvipsnames]{color}
%\setcounter{secnumdepth}{6}
\usepackage{authblk}
\usepackage{definitions}

\newcommand\rulename[1]{\mathrm{(#1)}}
\newcommand{\nothing}{\varnothing} % different from \emptyset
\newcommand{\tto}{\longrightarrow}
\newcommand{\lto}{\leftarrow}

\newcommand{\conf}[2][s]{(#2)[#1]}
\newcommand{\confxu}[1]{#1 [x,\{(v:T_1)\}:s]}
\newcommand{\confxD}[1]{#1 [\subxD]}
\newcommand{\confx}[1]{#1 [\SubxD}
\newcommand{\confy}[1]{#1 [\SubyD]}
\newcommand{\confext}[1]{#1 [x \mapsto(w:T_1) \oplus s]}
%\newcommand{\confxE}[1]{#1 [x,(v:T_1):s']}
%\newcommand{\confyE}[1]{#1 [y,(v:T_1):s']}

\newcommand{\subx}{x \mapsto \{\overline{w}\},s}	    
\newcommand{\subxD}{x \mapsto \{(\overline{w:T})\},s}
\newcommand{\SubxD}{x \mapsto \{(\overline{w:T_1})\},s}
\newcommand{\SubyD}{y \mapsto \{(\overline{w:T_1})\},s}
\newcommand{\Subx}{x \mapsto \{(\overline{v:T})\},s'}
\newcommand{\Suby}{y \mapsto \{(\overline{v:T})\},s'}
%\newcommand{\subx}{[x,(v:T_1):s']}
%\newcommand{\suby}{[y,(v:T_1):s']}

\newcommand{\tyC}{{\Gamma \vdash_c \ }}
\newcommand{\env}{{\Gamma \vdash \ }}

\newcommand{\envE}{{\Gamma , x:T_1  ; \emt \vdash \ }}
\newcommand{\enve}{{\Gamma ; \emt  \oplus (x : T_1)  \vdash \ }}

\newcommand{\envC}{{\Gamma ; \emt(s) \vdash \ }}
\newcommand{\envEC}{{\Gamma , x:T_1 ; \emt(s) \vdash \ }}
\newcommand{\enveC}{{\Gamma ;  \emt(s) \oplus (x : T_1) \vdash \ }}


\newcommand{\ascrip}[1]{#1::T}
\newcommand{\ascripP}[2]{#1::#2}
\newcommand{\oletD}{\mathsf{mlet} \ x : T = t \ \mathsf{in}  \ t}
\newcommand{\olet}{\mathsf{mlet} \ x : T_1 = t_1 \ \mathsf{in}  \ t_2}
\newcommand{\oletP}[3]{\mathsf{mlet} \ x : #1 = #2 \ \mathsf{in}  \ #3}
\newcommand{\app}[2]{#1 \ #2}
\newcommand{\appD}{t_1 \ t_2}
\newcommand{\abs}[3]{\lambda #1:#2. \ #3}
\newcommand{\absD}{\lambda x:T_1. \ t_2}
%\newcommand{\suma}[2]{#1 + #2}
\newcommand{\negacion}[1]{\mathsf{not} \ #1}
\newcommand{\suma}[1]{\mathsf{add1} \ #1}

\newcommand{\lab}{\mathsf{tag}}
\newcommand{\undefmy}{\mathsf{undef}}
\newcommand{\truet}{\mathsf{true}}
\newcommand{\falset}{\mathsf{false}}
\newcommand{\boolt}{\mathsf{Bool}}
\newcommand{\intt}{\mathsf{Int}}
\newcommand{\funt}{\mathsf{Fun}}
\newcommand{\selvt}{\mathsf{selvt}}
\newcommand{\selvv}{\mathsf{selvv}}

\newcommand{\mtD}{T^{*}}
\newcommand{\mtP}[1]{#1^{*}}
\newcommand{\mtC}[1]{\{\overline {#1}\}}
\newcommand{\mtCu}[1]{\{ #1 \}}

\newcommand{\emt}{\phi}
\newcommand{\conc}{:^{*}}

\newcommand{\tagi}[2]{<#1, #2>}


\newcommand{\errorA}{\mathsf{Error1}}
\newcommand{\errorB}{\mathsf{Error2}}
\newcommand{\errorC}{\mathsf{Error3}}
\newcommand{\errorD}{\mathsf{Error4}}
\newcommand{\errorE}{\mathsf{Error5}}

\newcommand\inferir{\stackrel{\mathclap{\normalfont\mbox{$\to$}}}{\in}}
\newcommand\chequear{\stackrel{\mathclap{\normalfont\mbox{$\lto$}}}{\in}}
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\providecommand{\norm}[1]{\lVert#1\rVert}

\newcommand{\clases}[1][D]{\mathsf{class} \ C \ \mathsf{extends} \ #1 \ \{ \overline{C} \ \overline{f}; \ K; \ \overline{M}\}}
\newcommand{\constructor}{ C(\overline{C} \ \overline{f})\{\mathsf{super}(\overline{f}); \ \mathsf{this}.\overline{f} =  \overline{f} \}}
\newcommand{\metodo}[1][C]{#1 \ m \ (\overline{#1} \ \overline{x})\{\mathsf{return} \ e;\}}
\newcommand{\metodoV}[1]{C_{#1} \ m \ (\overline{C_{#1}} \ \overline{x})\{\mathsf{return} \ e_{#1};\}}
\newcommand{\expresion}{x \ | \ e.f |\  \invocacion \ | \ \mathsf{new} \ C(\overline{e})}
\newcommand{\invocacion}{e.m(\overline{e})}
\newcommand{\valore}{\mathsf{new} \ C(\overline{v})}
\newcommand{\mtypesel}{\mathsf{mtypesel} (m, C, \overline{C})}
\newcommand{\mtype}[1][C]{\mathsf{mtype} (m, #1)}
\newcommand{\fields}[1][C]{\mathsf{fields} (#1)}
\newcommand{\mbody}[1][C]{\mathsf{mbody} (m, #1,\overline{B})}
\newcommand{\wellformed}[1][B]{\mathsf{wellformed} (\{\overline {\overline{#1} \to #1}\})}
\newcommand{\multt}[1][B]{\{ \overline{\overline{#1} \to #1} \}}


\title{\bf Overloading}
\author{Elizabeth Labrada Deniz
\thanks{Funded by grant CONICYT, CONICYT-PCHA/Doctorado Nacional/2015-63140148}}
\affil{Computer Science Department (DCC), University of Chile, Chile}
\date{}
\setcounter{Maxaffil}{0}
\renewcommand\Affilfont{\itshape\small}

\begin{document}
%\textheight = 600pt
%\topmargin = -40pt
%\oddsidemargin = -10pt

%\marginparwidth = 10pt
%\marginparsep = 0pt
%\paperheight = 800pt
%\textwidth = 1000pt
\setlength{\columnsep}{20pt} %settting space column

	\maketitle
	\renewcommand{\abstractname}{Abstract}	
	\begin{abstract}
	\end{abstract}	
\section{Introduction}

In this brief survey, we present concept related to overloading and relevant works that formalize overloading with different characteristics.
\section{Background}\label{section:concepts}
In this section we explain some concepts related to overloading, like polymorphism and the different kind of overloading.
\subsection{Polymorphism}
\begin{itemize}
\item Cardelli and Wegner~\cite{CardelliWegner} present a classification of the different types of polyphormism which result relevant to understand overloading and its differences with another kind of polyphormism.
\item Parametric polymorphism ~\cite{CardelliWegner, scott, wadlerBlott:popl89} Concept and example
\item Inclusion polymorphism Concept and example
\item Overloading ~\cite{CardelliWegner, wadlerBlott:popl89} Concept and example
\item Coercion ~\cite{CardelliWegner}  Concept and example
\item \[ Polyphormism = 
\begin{cases} 
     universal & 
     \begin{cases} 
     	parametric &\\
     	inclusion &
   	\end{cases} \\
		 & \\
     ad \ hoc & 
     \begin{cases} 
     	overloading & \\
     	coercion &
   	\end{cases}
 \end{cases}
\]
\end{itemize}
\subsection{Static Overloading}  
\begin{itemize}
\item Concept and example
\end{itemize}
\subsection{Dynamic Overloading}
\begin{itemize}
\item Concept and example
\item Common Lisp Object System(CLSO)~\cite{Bobrow:1988:CLO:885631.885632} is an object-oriented extension to Common Lisp which implements dynamic overloading. It is worth noting that CLSO do not admit any static checking, therefore is dynamically typed. 
\end{itemize}
\section{Overloading}\label{section:polymorphism}
In the preset section we report some different works related to the overloading field. We start with type class, a powerful mechanism which allow overloading, combined with parametric polyphormism. Then we present an interesting work that explain overloading in object-oriented programming languages, with static or dynamic overloading.
\subsection{Type classes}
\begin{itemize}
\item Type class in Haskell~\cite{wadlerBlott:popl89} is a sort of interface that defines some behavior supporting overloading and parametric polymorphism. A type class is defined by Nipkow et al.~\cite{Nipkow1993}	, as a set of types, which all happen to provide a certain set of functions.
\item Example type class  class Eq
\item All articles revised use Hindley/Damas/Milner system. Every expression which
has a type has a most general type which can be inferred automatically~\cite{Nipkow1993}.
\item In the work of Camar\~ao et al. ~\cite{Camarao1999} is summarized some of the limitations or requirements of type classes such as: the declaration of an overloaded function requires a class declarations, all the overloaded instances must share a common type pattern and definitions of overloaded symbols must occur in global instance declarations.
\item open world assumption where the
set of declared instances is considered open to extension (from different modules,
introduced at link time).
\item Context-dependent overloading, is a form of overloading where the selection of the definition for an application function depends not only on the types of the arguments, but also on the call context. For instance,  if we have the  expression $m \ e$, we use for the correct selection of the definition of $m$, the type of $e$ and the information of the context in which  $m \ e$ is used.
\item Ribeiro and Camar\~ao~\cite{Ribeiro2013} note that a type system for Haskell allows distinct derivations for ambiguous expressions, which are usually rejected by the type inference algorithm. Also, they remark that the Haskell's open world approach affects the standard definition of ambiguity.
\item Coherence establishes a single well-defined meaning for each expression.
 \item Since the original type inference system is undecidable [7], some additional (syntactical) restrictions had to be imposed to obtain a type system where most general typings can efectively be computed~\cite{SEIDL199457}.
 \item Type checking type classes~\cite{Nipkow1993}.
\item A second look at overloading ~\cite{Odersky1995}.
\item Type Inference for Overloading without Restrictions, Declarations or Annotations ~\cite{Camarao1999}
\end{itemize}
\subsection{Overloading in Object Oriented Paradigm}
\begin{itemize}
\item Featherweight Multi Java (FMJ)~\cite{BETTINI2009261, FJM} is an extension of Featherweight Java (FJ)~\cite{FJ} with multi-methods.
\item All the inherited overloaded methods are copied into the subclass.
  \item The receiver type of the method invocation has no precedence over the argument types, when the  dynamic overloading selection is performed.
  \item All method invocations are annotated with the type selected during static type checking, in order to choose the best specialized branch during the dynamic overloading method selection. Thus, at run-time it is sound  to select only a specialization of the static type.
  \item A procedure to select the most appropriate branch at run-time using both the dynamic type of the arguments and the annotated static type guarantees that no ambiguity can dynamically occur in well-typed programs.
  \item In FMJ is used the concept of multi-types, which represents the types of  multi-methods. Formally, a multi-types is a set of arrows types
  \item The approach of~\cite{BETTINI2009261} propose an straightforward  way to obtain    static overloading, changing the rule $\rulename{RInvk}$ by the rule $\rulename{RSInvk}$.
  \item It is important to note that FMJ, and more general Java, only admit overloaded method invocation, unlike type classes. Type classes allow function calls and function arguments overloaded. The reason for this is that in Java, the functions are not first-class citizen. 
\end{itemize}






%Bibliography
\medskip 
\bibliographystyle{abbrv}
\bibliography{gsta,pleiad,gp,bib,common}
\end{document}
